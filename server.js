const express = require('express');
const cors = require('cors');
const http = require('http');
const socketIo = require('socket.io');
const path = require('path');

const app = express();
const server = http.createServer(app);

// Configure CORS for your Render frontend
const io = socketIo(server, {
  cors: {
    origin: [
      "https://frontend-aibot.onrender.com",
      "http://localhost:3000",
      "http://localhost:5173"
    ],
    methods: ["GET", "POST"],
    credentials: true
  }
});

app.use(cors());
app.use(express.json({ limit: '10mb' }));

// Serve static files from 'public' directory
app.use(express.static('public'));

// Configuration
const OLLAMA_BASE_URL = process.env.OLLAMA_BASE_URL || 'http://localhost:11434';
const OLLAMA_MODEL = process.env.OLLAMA_MODEL || 'medllama2:latest';
const ADMIN_SECRET = process.env.ADMIN_SECRET || 'iamtheserver2024';

// Store blocked IPs and users
const blockedIPs = new Map();
const blockedUsers = new Map();
const activeConnections = new Map();
const chatHistory = [];

// Medical Context
const MEDICAL_CONTEXT = ' ';

class RemoteOllamaService {
  async generateResponse(userMessage, socket) {
    return new Promise(async (resolve, reject) => {
      try {
        console.log('ðŸ’¬ Medical query received:', userMessage.substring(0, 100));
        
        const medicalPrompt = MEDICAL_CONTEXT + "\n\nØ§Ù„Ù…Ø±ÙŠØ¶: " + userMessage + "\n\nØ§Ù„Ù…Ø³Ø§Ø¹Ø¯:";
        
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 60000);

        const response = await fetch(`${OLLAMA_BASE_URL}/api/generate`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            model: OLLAMA_MODEL,
            prompt: medicalPrompt,
            stream: true,
            options: {
              temperature: 0.7,
              top_p: 0.9,
              top_k: 40
            }
          }),
          signal: controller.signal
        });

        clearTimeout(timeout);

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let fullResponse = '';
        let buffer = '';

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';

          for (const line of lines) {
            if (line.trim() === '') continue;
            
            try {
              const data = JSON.parse(line);
              if (data.response) {
                fullResponse += data.response;
                if (socket && socket.connected) {
                  socket.emit('streaming_response', {
                    text: fullResponse,
                    partial: !data.done
                  });
                }
              }
              
              if (data.done) {
                if (socket && socket.connected) {
                  socket.emit('streaming_response', {
                    text: fullResponse,
                    partial: false,
                    complete: true
                  });
                }
                resolve(fullResponse);
                return;
              }
            } catch (e) {
              console.warn('âš ï¸ JSON parse error:', e.message);
            }
          }
        }

        resolve(fullResponse);
        
      } catch (error) {
        console.error('âŒ Ollama service error:', error);
        const fallbackResponse = "Ø¹Ø°Ø±Ù‹Ø§ØŒ Ø§Ù„Ø®Ø¯Ù…Ø© Ø§Ù„Ø·Ø¨ÙŠØ© ØºÙŠØ± Ù…ØªØ§Ø­Ø© Ø­Ø§Ù„ÙŠÙ‹Ø§. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ù‹Ø§ Ø£Ùˆ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø·Ø¨ÙŠØ¨Ùƒ Ù…Ø¨Ø§Ø´Ø±Ø©.";
        
        if (socket && socket.connected) {
          socket.emit('streaming_response', {
            text: fallbackResponse,
            partial: false,
            complete: true,
            error: true
          });
        }
        
        resolve(fallbackResponse);
      }
    });
  }
}

const medicalService = new RemoteOllamaService();

// ==================== RENDER FIXES ====================

// SIMPLE HEALTH CHECK - RENDER REQUIRES THIS
app.get('/health', (req, res) => {
  res.status(200).json({ 
    status: 'OK', 
    service: 'Medical Chatbot',
    timestamp: new Date().toISOString()
  });
});

// ROOT ENDPOINT
app.get('/', (req, res) => {
  res.json({ 
    message: 'ðŸ¥ Tunisian Medical Chatbot Server is running',
    status: 'healthy',
    timestamp: new Date().toISOString()
  });
});

// Health check endpoint
app.get('/api/health', async (req, res) => {
  try {
    res.json({
      status: 'OK',
      service: 'Tunisian Medical Chatbot',
      timestamp: new Date().toISOString(),
      environment: process.env.NODE_ENV || 'development'
    });
  } catch (error) {
    res.status(500).json({
      status: 'ERROR',
      message: 'Health check failed'
    });
  }
});

// Test endpoint
app.get('/api/test', (req, res) => {
  res.json({
    message: 'Medical chatbot server is running!',
    timestamp: new Date().toISOString()
  });
});

// Serve admin panel
app.get('/admin', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'admin.html'));
});

// Socket.io connection handling
io.on('connection', (socket) => {
  console.log('ðŸ”Œ User connected:', socket.id);
  
  const userInfo = {
    connectedAt: new Date(),
    ip: socket.handshake.address,
    userAgent: socket.handshake.headers['user-agent'],
    isAdmin: false
  };
  
  activeConnections.set(socket.id, userInfo);

  // Send welcome message
  socket.emit('welcome', {
    message: 'Ø£Ù‡Ù„Ø§Ù‹ ÙˆØ³Ù‡Ù„Ø§Ù‹! Ø£Ù†Ø§ Ù…Ø³Ø§Ø¹Ø¯Ùƒ Ø§Ù„Ø·Ø¨ÙŠ Ø§Ù„ØªÙˆÙ†Ø³ÙŠ. ÙƒÙŠÙ ÙŠÙ…ÙƒÙ†Ù†ÙŠ Ù…Ø³Ø§Ø¹Ø¯ØªÙƒ Ø§Ù„ÙŠÙˆÙ…ØŸ',
    id: socket.id,
    timestamp: new Date().toISOString()
  });

  // Handle incoming messages
  socket.on('send_message', async (data) => {
    if (!data.message || data.message.trim().length === 0) {
      socket.emit('error', { message: 'Ø§Ù„Ø±Ø¬Ø§Ø¡ ÙƒØªØ§Ø¨Ø© Ø±Ø³Ø§Ù„Ø©.' });
      return;
    }

    try {
      console.log(`ðŸ“ Processing message from ${socket.id}`);
      await medicalService.generateResponse(data.message.trim(), socket);
    } catch (error) {
      console.error('ðŸ’¥ Message processing error:', error);
      socket.emit('error', { 
        message: 'Ø¹Ø°Ø±Ù‹Ø§ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.' 
      });
    }
  });

  // Handle disconnection
  socket.on('disconnect', (reason) => {
    console.log('ðŸ”Œ User disconnected:', socket.id, 'Reason:', reason);
    activeConnections.delete(socket.id);
  });

  // Admin authentication
  if (socket.handshake.auth.secret === ADMIN_SECRET) {
    console.log('ðŸ”“ Admin connected:', socket.id);
    userInfo.isAdmin = true;
    activeConnections.set(socket.id, userInfo);

    socket.emit('admin_welcome', { 
      message: 'ðŸ”“ Ø£Ù†Øª Ù…ØªØµÙ„ ÙƒÙ…Ø³Ø¤ÙˆÙ„',
      socketId: socket.id
    });
  }
});

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({
    error: 'Endpoint not found',
    message: 'Ø¹Ø°Ø±Ù‹Ø§ØŒ Ø§Ù„Ù…Ø³Ø§Ø± ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.'
  });
});

const PORT = process.env.PORT || 10000;

// ==================== FIXED SERVER STARTUP ====================
server.listen(PORT, () => {
  console.log(`
âœ… MEDICAL CHATBOT SERVER - RENDER FIXED
ðŸ“ Port: ${PORT}
ðŸŽ¯ Environment: ${process.env.NODE_ENV || 'development'}
ðŸ”— Ollama: ${OLLAMA_BASE_URL}
ðŸ¤– Model: ${OLLAMA_MODEL}

ðŸŒ Server URL: https://backend-aibot.onrender.com
ðŸ¥ Health Check: /health

âœ¨ Server is running and ready!
  `);
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('ðŸ”» SIGTERM received, shutting down gracefully...');
  server.close(() => {
    console.log('ðŸ”» Process terminated');
    process.exit(0);
  });
});

module.exports = app;
